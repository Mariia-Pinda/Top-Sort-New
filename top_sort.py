edges = {'a': ['c'], 'c': ['b'], 'd': ['c', 'b', 't'], 'b': [], 't': []}  # вхідні дані: словник, де ключі - вершини орграфа, а значення - вершини, суміжні з ними
stack = []                                                                # список для зберігання результату топологічного сортування
edges_list = []                                                           # список вершин графа

for key in edges:                                                         # додаємо вершини в список вершин
    edges_list.append(key)


def top_sort(edges, stack, edges_list):                                   # основна функція топологічного сортування: шукаємо витік, додаємо в результуючий стек, видаляємо витік зі списку вершин, повторюємо проіедуру
    while len(edges.keys()) != 0:
        for key in edges_list:
            values_list = []                                              # для кожної вершини створюємо список з вершин, що суміжні з нею
            for val in edges.values():
                for el in val:
                    values_list.append(el)
            if key not in values_list:                                    # шукаємо витік - вершину, якої немає в списку значень, тобто у яку не входить жодна дуга
                stack.append(key)                                         # додаємо витік у результуючий стек
                edges_list.remove(key)                                    # видаляємо його зі списку вершин, тобто цю вершину вже опрауювали
                edges.pop(key)                                            # видаляємо вершину з вихідного словника
    return stack


stack = top_sort(edges, stack, edges_list)                                 # виклик функції, запис результату в стек
print(stack)                                                               # результат - список вершин, що відсортовані за допомогою топологічного сортування



